\chapter{stream}

Una “vista” dei dati per specificare computazioni a un più alto livello concettuale rispetto alle collezioni e gli iteratori.

Supponiamo di voler calcolare la media dei salari di una collezione di oggetti Employee.
\begin{multicols}{2}
    Se decidessimo di usare gli iteratori
    \begin{itemize}
        \item dovremmo dichiarare una variabile per accumulare i risultati intermedi;
        \item iterare sulla sorgente dati, dove, ad ogni iterazione, aggiorniamo i risultati intermedi;
        \item alla fine, calcolare la media.
    \end{itemize}
    \columnbreak
    Se usassimo gli stream, basterebbe
    \begin{itemize}
        \item specificare la sorgente dati;
        \item la proprietà di interesse;
        \item cosa vogliamo fare con quella proprietà.
    \end{itemize}
    La libreria stream farà tutto il resto ottimizzando il calcolo.
\end{multicols}

Rispettano il principio "“what, not how", ovvero si specifica cosa si vuole fare e non il come deve essere fatto. 

Stream e collezioni, superficialmente, sembrano simili, entrambi permettono di trasformare e recuperare dati ma 
\begin{itemize}
    \item uno stream non \textit{memorizza} i dati, sono memorizzati nella collezione originale o generati su richiesta;
    \item uno stream non \textit{modifica} i dati originali, ma genera un nuovo stream dove alcuni elementi dello stream precendete non sono presenti nello stream 
    corrente;
    \item le operazioni sono "\textit{lazy}" quanto il più possibile, ovvero non vengono eseguite finché non serve il risultato (si possono avere anche 
    stream infiniti).
\end{itemize}

Gli stream si basano sul \textit{method chaining}, ovvero chiamano un metodo sul risultato di un altro metodo, senza memorizzare i risultati intermedi.

Il workflow tipico di uno stream consiste nel creare una “pipeline” di operazioni in 3 fasi:
\begin{itemize}
    \item creazione dello stream;
    \item specifica delle operazioni intermedie;
    \item applicazione di un’operazione finale di riduzione per produrre un risultato oppure un'operazione di raccolta.
\end{itemize}

\section{Creazione di uno stream}

Gli stream si creano da collezioni e array o usando generatori o iteratori.

Per le collezioni abbiamo i metodi stream() e parallelStream(), per gli array o un numero arbitrario di argomenti (vararg) abbiamo il metodo statico\newline 
Stream.of() e poi abbiamo i metodi Stream.generate(Supplier $<$T$>$) e Stream.iterate(T seed, UnaryOperator$<$T$>$ f).

Gli ultimi due metodi possono genera stream infiniti.

\subsection{Stream infiniti}
Stream.generate(Supplier $<$T$>$) prende una lambda senza argomenti e viene chiamato solo quando viene richiesto allo stream il prossimo elemento
\begin{lstlisting}
Stream<String> echos = Stream.generate(() -> "Echo");
Stream<Double> randoms = Stream.generate(Math::random); 
\end{lstlisting}

Stream.iterate(T seed, UnaryOperator$<$T$>$ f) dove seed è il "seme" iniziale mentre f è una funzione che sarà applicata al valore precendete
\begin{lstlisting}
Stream<BigInteger> integers = Stream.iterate(BigInteger.ZERO, n -> n.add(BigInteger.ONE))   
\end{lstlisting}

\section{Operazioni intermedie}

Le operazioni intermedie di uno stream sono metodi che trasformano lo stream in un altro stream.

Tra questi metodi troviamo filter() che si occupa di filtrare uno stream, map() che si occupa di trasformare gli elementi di uno stream, limit() che limita ad un
certo numero di elemnti dello stream (occhio a dove lo mettiamo), skip() che salta determinati elementi dello stream, distinct() che scarta i rislutati, etc\dots

Con gli stream si scrivere meno codice, è più leggibile ma allo stesso tempo è molto facile commettere errori, i due prossimi stream forniscono un risultato differente

\begin{lstlisting}
#SI LIMITA ALLE PRIME 5 STRINGHE CHE RISPETTANO IL FILTRO
long count = words.stream()
                    .filter(w -> w.length() > 12)
                    .limit(5)
                    .count();
#SI LIMITA ALLE PRIME 5 STRINGHE                    
long count = words.stream()
                    .limit(5)
                    .filter(w -> w.length() > 12)
                    .count();
\end{lstlisting}

\section{Operazione di riduzione di uno stream}

Una volta applicate tutte le operazioni di trasformazione, alla fine si deve applicare un’operazione di riduzione.

Alcuni metodi di riduzione sono min() e max() che restituiscono, rispettivamente, il minimo ed il massimo di uno stream in base ad un criterio.

Questa forzerà l’esecuzione di tutte le operazioni lazy precedenti e dopo questa ultima operazione lo stream non potrà più essere usato.

Alcuni di queste operazioni restituiscono un oggetto di classe Optional, un’alternativa più sicura della gestione dei valori null come ad esempio findFirst(), 
ifPresent(), etc\dots

\input{streams/optional}

\section{Operazione di raccolta di uno stream}

Un'alternativa alla riduzione di uno stream è la raccolta.

Ci sono molti metodi tra cui il metodo collect() che prende in input oggetti che implementano l'interfaccia Collector, tra cui Collectors che fornisce metodi 
per creare istanze delle collezioni più comuni.

Abbiamo anche toMap(), groupingBy() o partitionBy().


